import { componentRegistry } from '../data/componentRegistry.js';
import { generateId, cleanString, capitalize } from './parserUtils';

/**
 * Parses SPR (Screen Program) content and populates the form state.
 * 
 * SPR files are generated by FoxPro's Screen Builder (GENSCRN).
 * This parser handles legacy @ SAY/GET commands and DEFINE WINDOW definitions.
 * 
 * @param {string} text - The raw SPR content
 * @param {Function} setCanvasSize - State setter for canvas dimensions
 * @param {Function} setWidgets - State setter for form elements
 * @param {Function} setSelectedId - State setter for selection
 * @param {Function} setFormEvents - State setter for form events
 * @param {Function} setFormName - State setter for form name
 * @param {Function} setFormProps - State setter for form properties (caption, etc.)
 */
export const parseSPRContent = (text, setCanvasSize, setWidgets, setSelectedId, setFormEvents, setFormName, setFormProps) => {
    const lines = text.split('\n');

    // Initialize counters locally for this parse session
    const counters = {
        label: 0, textbox: 0, button: 0, checkbox: 0, radio: 0,
        combobox: 0, grid: 0, image: 0, shape: 0, container: 0,
        editbox: 0, spinner: 0
    };

    const getNextName = (type) => {
        if (counters[type] === undefined) counters[type] = 0;
        counters[type]++;
        const prefix = type.charAt(0).toUpperCase() + type.slice(1);
        return `${prefix}${counters[type]}`;
    };

    const procedures = parseProcedures(lines);

    const { newWidgets, finalFormEvents, formName, canvasSize, formTitle } = parseWidgets(lines, procedures, getNextName);

    setCanvasSize(canvasSize);
    setWidgets(newWidgets);
    setFormEvents(finalFormEvents);
    if (setFormName) setFormName(formName);

    if (setFormProps && formTitle) {
        setFormProps(prev => ({
            ...prev,
            caption: formTitle
        }));
    }

    setSelectedId(null);
    if (typeof console !== 'undefined') console.log(`Načteno ${newWidgets.length} prvků z SPR formátu.`);
};

// --- Helper Functions ---

const ROW_HEIGHT = 25;
const COL_WIDTH = 10;
const PADDING_TOP = 10;
const PADDING_LEFT = 10;

const parseProcedures = (lines) => {
    const procedures = {};
    let currentProcName = null;
    let currentProcCode = [];
    let inProcedure = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line.match(/^PROCEDURE\s+(\w+)/i)) {
            const match = line.match(/^PROCEDURE\s+(\w+)/i);
            if (currentProcName) {
                procedures[currentProcName.toUpperCase()] = 'pass\n' + currentProcCode.map(l => '# ' + l).join('\n');
            }
            currentProcName = match[1];
            inProcedure = true;
            currentProcCode = [];
            continue;
        }

        if (inProcedure) {
            if (line.startsWith('*-eof')) {
                inProcedure = false;
                continue;
            }
            currentProcCode.push(lines[i]);
        }
    }
    if (currentProcName) {
        procedures[currentProcName.toUpperCase()] = 'pass\n' + currentProcCode.map(l => '# ' + l).join('\n');
    }
    return procedures;
};

const parseCaption = (caption) => {
    let text = caption || '';
    let enabled = true;
    let hotkey = null;
    let isDefault = false;
    let isCancel = false;

    if (text.includes('\\\\')) { enabled = false; text = text.replace(/\\\\/g, ''); }
    if (text.includes('\\!')) { isDefault = true; text = text.replace(/\\!/g, ''); }
    if (text.includes('\\?')) { isCancel = true; text = text.replace(/\\\?/g, ''); }

    const hotkeyMatch = text.match(/\\<(.?)/);
    if (hotkeyMatch) {
        hotkey = hotkeyMatch[1];
        text = text.replace(/\\</g, '');
    }
    text = text.replace(/\\/g, '');

    return { text, enabled, hotkey, isDefault, isCancel };
};

const evalExpr = (expr) => {
    try {
        if (!expr) return 0;
        let e = expr.toUpperCase().replace(/SROWS\(\)/g, 25).replace(/SCOLS\(\)/g, 80);
        e = e.replace(/INT\(/g, 'Math.floor(');
        return new Function(`return ${e}`)();
    } catch (err) {
        console.error('Error evaluating expression:', expr, err);
        return 0;
    }
};

const splitCoords = (str) => {
    const commaIdx = str.indexOf(',');
    if (commaIdx === -1) return [0, 0];
    return [str.substring(0, commaIdx), str.substring(commaIdx + 1)];
};

const parseWidgets = (lines, procedures, getNextName) => {
    const newWidgets = [];
    const finalFormEvents = {};
    let formName = 'Form1';
    let formTitle = 'Form1';
    let formWidth = 800;
    let formHeight = 600;

    const sayPattern = /@\s*([\d\.]+)\s*,\s*([\d\.]+)\s+SAY\s+(.*)/i;
    const getPattern = /@\s*([\d\.]+)\s*,\s*([\d\.]+)\s+GET\s+(.*)/i;
    const windowPattern = /DEFINE\s+WINDOW\s+(\w+)/i;

    lines.forEach(line => {
        const cleanLine = line.trim();
        if (!cleanLine || cleanLine.startsWith('*') || cleanLine.startsWith('PROCEDURE')) return;

        // Window Definition
        const winMatch = cleanLine.match(windowPattern);
        if (winMatch && !cleanLine.match(/\s+IN\s+(\w+)/i)) {
            formName = winMatch[1];
            const dimMatch = cleanLine.match(/FROM\s+(.+?)\s+TO\s+(.+?)(?:\s+(?:NOFLOAT\b|NOCLOSE\b|NOSHADOW\b|NOGROW\b|NOZOOM\b|NOMINIMIZE\b|FLOAT\b|SHADOW\b|TITLE\b|COLOR\b|SCHEME\b|SYSTEM\b|GROW\b|MINIMIZE\b|CLOSE\b|ZOOM\b|DOUBLE\b|PANEL\b|NONE\b|FONT\b|STYLE\b|ICON\b|MDI\b|HALFHEIGHT\b|FOOTER\b|FILL\b|FILE\b|IN\b|NAME\b)|$)/i);
            if (dimMatch) {
                const [r1s, c1s] = splitCoords(dimMatch[1]);
                const [r2s, c2s] = splitCoords(dimMatch[2]);
                const row1 = evalExpr(r1s);
                const col1 = evalExpr(c1s);
                const row2 = evalExpr(r2s);
                const col2 = evalExpr(c2s);
                if (!isNaN(row1) && !isNaN(col1) && !isNaN(row2) && !isNaN(col2)) {
                    formWidth = Math.round((col2 - col1 + 1) * COL_WIDTH);
                    formHeight = Math.round((row2 - row1 + 1) * ROW_HEIGHT);
                }
            }

            // Extract Title
            const titleMatch = cleanLine.match(/TITLE\s+(?:'|")(.+?)(?:'|")/i);
            if (titleMatch) {
                formTitle = titleMatch[1];
            }
        }

        // READ CYCLE
        if (cleanLine.match(/READ\s+CYCLE/i)) {
            parseReadCycle(cleanLine, procedures, finalFormEvents, newWidgets, getNextName);
        }

        // SAY (Labels)
        let match;
        if ((match = cleanLine.match(sayPattern))) {
            const { row, col, content, w, h } = parseCoordinatesAndSize(match);
            const text = cleanString(content);
            const id = generateId();
            newWidgets.push({
                id, type: 'label',
                x: Math.round(col * COL_WIDTH + PADDING_LEFT),
                y: Math.round(row * ROW_HEIGHT + PADDING_TOP),
                props: {
                    text, width: Math.round(w * COL_WIDTH), height: Math.round(h * ROW_HEIGHT),
                    name: getNextName('label'),
                    style: { fontSize: '14px', color: '#000000' }
                }
            });
        }
        // GET (Controls)
        else if ((match = cleanLine.match(getPattern))) {
            parseGetControl(match, cleanLine, newWidgets, finalFormEvents, procedures, getNextName);
        }
    });

    return { newWidgets, finalFormEvents, formName, canvasSize: { width: formWidth, height: formHeight }, formTitle };
};

const parseCoordinatesAndSize = (match) => {
    const row = parseFloat(match[1]);
    const col = parseFloat(match[2]);
    let content = match[3];
    let w = 10;
    let h = 1;

    const sizeMatch = content.match(/\s+SIZE\s+([\d\.]+)\s*,\s*([\d\.]+)/i);
    if (sizeMatch) {
        h = parseFloat(sizeMatch[1]);
        w = parseFloat(sizeMatch[2]);
        content = content.substring(0, sizeMatch.index);
    } else {
        const textMatch = content.match(/^['"](.*)['"]$/);
        const text = textMatch ? textMatch[1] : content.trim();
        w = text.length;
    }
    return { row, col, content, w, h };
};

const parseGetControl = (match, cleanLine, newWidgets, finalFormEvents, procedures, getNextName) => {
    const { row, col, content, w, h } = parseCoordinatesAndSize(match);

    let validProc = null;
    const validMatch = cleanLine.match(/\s+VALID\s+(\w+)(\(\))?/i);
    if (validMatch) validProc = validMatch[1];

    const varMatch = content.match(/^([^\s]+)/);
    const varName = varMatch ? varMatch[1].replace(/^m\./i, '') : 'unknown';

    const picMatch = cleanLine.match(/PICTURE\s+['"](.*?)['"]/i);
    const funcMatch = cleanLine.match(/FUNCTION\s+['"](.*?)['"]/i);
    const clauses = (picMatch ? picMatch[1] : '') + (funcMatch ? funcMatch[1] : '');

    let type = 'textbox';
    let props = { name: varName, text: varName };
    let isGroup = false;
    let groupOptions = [];
    let groupOrientation = 'H';

    const clauseMatch = clauses.match(/^(?:@?)\*([A-Z]*)(?:\s+(.*))?$/i);

    if (clauseMatch) {
        const modifiers = clauseMatch[1].toUpperCase();
        const rawCaptionPart = clauseMatch[2] || '';

        if (modifiers.includes('C')) {
            type = 'checkbox';
            props.text = cleanString(rawCaptionPart.replace(/\\<|\\/g, ''));
        } else if (modifiers.includes('R')) {
            type = 'radio';
            if (modifiers.includes('V')) groupOrientation = 'V';
            if (rawCaptionPart.includes(';')) {
                isGroup = true;
                groupOptions = rawCaptionPart.split(';');
            } else {
                const parsed = parseCaption(rawCaptionPart);
                props.text = parsed.text;
                if (!parsed.enabled) props.enabled = false;
                if (parsed.hotkey) props.hotkey = parsed.hotkey;
            }
        } else {
            type = 'button';
            if (modifiers.includes('V')) groupOrientation = 'V';
            if (rawCaptionPart.includes(';')) {
                isGroup = true;
                groupOptions = rawCaptionPart.split(';');
            } else {
                const parsed = parseCaption(rawCaptionPart || 'Button');
                props.text = parsed.text;
                if (!parsed.enabled) props.enabled = false;
                if (parsed.hotkey) props.hotkey = parsed.hotkey;
                if (parsed.isDefault) props.default = true;
                if (parsed.isCancel) props.cancel = true;
            }
        }
    } else if (clauses.includes('^')) {
        type = 'combobox';
        const captionPartMatch = clauses.match(/@\^\s+(.*)$/i);
        if (captionPartMatch) {
            props.options = captionPartMatch[1].split(';').map(o => o.trim());
        }
    }

    const startX = Math.round(col * COL_WIDTH + PADDING_LEFT);
    const startY = Math.round(row * ROW_HEIGHT + PADDING_TOP);

    if (isGroup) {
        groupOptions.forEach((opt, idx) => {
            const parsed = parseCaption(opt);
            const id = generateId();
            const widget = {
                id,
                type: type === 'radio' ? 'radio' : 'button',
                x: startX + (groupOrientation === 'H' ? idx * Math.round(w * COL_WIDTH) : 0),
                y: startY + (groupOrientation === 'V' ? idx * Math.round(h * ROW_HEIGHT) : 0),
                props: {
                    text: parsed.text,
                    width: Math.round(w * COL_WIDTH),
                    height: Math.round(h * ROW_HEIGHT),
                    name: getNextName(type === 'radio' ? 'radio' : 'button'),
                    style: { fontSize: '14px', color: '#000000', backgroundColor: type === 'radio' ? undefined : '#f0f0f0' }
                }
            };
            if (!parsed.enabled) widget.props.enabled = false;
            if (parsed.hotkey) widget.props.hotkey = parsed.hotkey;
            if (parsed.isDefault) widget.props.default = true;
            if (parsed.isCancel) widget.props.cancel = true;

            if (validProc) finalFormEvents[`${id}_Click`] = procedures[validProc.toUpperCase()];
            newWidgets.push(widget);
        });
    } else {
        const id = generateId();
        const widget = {
            id, type, x: startX, y: startY,
            props: {
                ...props,
                width: Math.round(w * COL_WIDTH),
                height: Math.round(h * ROW_HEIGHT),
                style: { fontSize: '14px', color: '#000000', backgroundColor: type === 'button' ? '#f0f0f0' : undefined, ...props.style }
            }
        };
        if (validProc && procedures[validProc.toUpperCase()]) {
            const eventName = (type === 'button' || type === 'checkbox' || type === 'radio') ? 'Click' : 'LostFocus';
            finalFormEvents[`${id}_${eventName}`] = procedures[validProc.toUpperCase()];
        }
        newWidgets.push(widget);
    }
};

const parseReadCycle = (cleanLine, procedures, finalFormEvents, newWidgets, getNextName) => {
    const showMatch = cleanLine.match(/SHOW\s+(\w+)/i);
    const activateMatch = cleanLine.match(/ACTIVATE\s+(\w+)/i);
    const deactivateMatch = cleanLine.match(/DEACTIVATE\s+(\w+)/i);

    if (activateMatch) {
        const procName = activateMatch[1].toUpperCase();
        if (procedures[procName]) {
            finalFormEvents['Form1_Load'] = procedures[procName];
            parseEmbeddedWidgets(procedures[procName], newWidgets, getNextName);
        }
    }
    if (showMatch) {
        const procName = showMatch[1].toUpperCase();
        if (procedures[procName]) {
            finalFormEvents['Form1_Init'] = procedures[procName];
            parseEmbeddedWidgets(procedures[procName], newWidgets, getNextName);
        }
    }
    if (deactivateMatch) {
        const procName = deactivateMatch[1].toUpperCase();
        if (procedures[procName]) finalFormEvents['Form1_Unload'] = procedures[procName];
    }
};

const parseEmbeddedWidgets = (procCode, newWidgets, getNextName) => {
    // Check for nested window definition
    const nestedWinMatch = procCode.match(/DEFINE\s+WINDOW\s+(\w+)\s+FROM\s+([\d\.,\s\(\)\+\-\*\/]+)\s+TO\s+([\d\.,\s\(\)\+\-\*\/]+)\s+IN\s+(\w+)/i);

    if (nestedWinMatch) {
        const winName = nestedWinMatch[1];
        const fromPart = nestedWinMatch[2];
        const toPart = nestedWinMatch[3];

        const [r1s, c1s] = splitCoords(fromPart);
        const [r2s, c2s] = splitCoords(toPart);
        const row1 = evalExpr(r1s);
        const col1 = evalExpr(c1s);
        const row2 = evalExpr(r2s);
        const col2 = evalExpr(c2s);

        if (!isNaN(row1) && !isNaN(col1) && !isNaN(row2) && !isNaN(col2)) {
            const width = Math.round((col2 - col1 + 1) * COL_WIDTH);
            const height = Math.round((row2 - row1 + 1) * ROW_HEIGHT);
            const x = Math.round(col1 * COL_WIDTH + PADDING_LEFT);
            const y = Math.round(row1 * ROW_HEIGHT + PADDING_TOP);

            const id = generateId();
            newWidgets.push({
                id,
                type: 'container',
                x, y,
                props: {
                    width,
                    height,
                    name: getNextName('container'),
                    style: { border: '1px solid #ccc', backgroundColor: '#f0f0f0' }
                }
            });
        }
    }

    // Check for BROWSE command
    const browseMatch = procCode.match(/BROWSE\s+FIELDS\s+(.+?)\s+IN\s+(\w+)/i);
    if (browseMatch) {
        const fieldsPart = browseMatch[1];
        const containerName = browseMatch[2];

        // Try to find the container we just added or any container
        const foundContainer = newWidgets.find(w => w.type === 'container');

        if (foundContainer) {
            const columns = [];
            const fieldDefs = fieldsPart.split(/,(?=(?:[^']*'[^']*')*[^']*$)/).map(f => f.trim());

            fieldDefs.forEach(def => {
                const nameMatch = def.match(/^(?:[\w]+\.)?(\w+)/);
                const name = nameMatch ? nameMatch[1] : 'Column';

                const isReadOnly = /:R/i.test(def);
                const headerMatch = def.match(/:H\s*=\s*['"](.*?)['"]/i);
                const header = headerMatch ? headerMatch[1] : name;

                columns.push({
                    id: generateId(),
                    header: header,
                    field: name,
                    width: 100,
                    readonly: isReadOnly
                });
            });

            const gridId = generateId();
            newWidgets.push({
                id: gridId,
                type: 'grid',
                x: 0,
                y: 0,
                parentId: foundContainer.id,
                props: {
                    width: foundContainer.props.width,
                    height: foundContainer.props.height,
                    name: getNextName('grid'),
                    columns: columns,
                    data: [],
                    style: { fontSize: '14px', border: '1px solid #999' }
                }
            });
        }
    }
};
